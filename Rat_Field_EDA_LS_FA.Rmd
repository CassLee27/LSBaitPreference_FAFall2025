---
title: "Rat_Field_EDA_LS_FDA"
author: "Cass Lee"
date: "2025-09-16"
output: pdf_document
---

! For best results, run these code chunks sequentially in RStudio rather than creating a knitted document.

## Preliminary Set Up

```{r import libraries}
# import useful libraries
library(tidyverse)
library(mosaic)
library(ggformula)
library(dplyr)
library(lme4)
library(effects)
```

```{r import data}
# set import file path
path_f <- '~/Desktop/ENVR356/LS_FA/RatData.tsv'
# import full data set
all_data_f <- read_tsv(file = path_f,col_types = "ccntccncnnnncc",skip=2)
  # skip the two header rows
# change the column names
names(all_data_f) <- c("Camera","Month","Day","Time","FileName","LeftTubeTreatment","RatNumber","FirstTube","TimeLeft","TimeRight","TimeArea","TimeTotal", "Observer","Notes","A","B")
all_data_f <- all_data_f |> select(-A,-B)
```

```{r}
glimpse(all_data_f)

```
```{r}
# transform the data to account for video length
  # need to account for error in the human fallible timing...
  # there are so few rat videos that rather than timer we could maybe manually get the durations using video trimming clips
# for now, proportion can be bigger than 1 ig
analysis_data_f <- all_data_f |> mutate(
  MonthNum = case_when(Month == "Jul" ~ 7,
                         Month == "Aug" ~ 8,
                         Month == "Sep" ~ 9,
                         .default = NA),
  Date = as.POSIXct(paste("2025",MonthNum,Day,Time,sep=":"), tz="","%Y:%m:%d:%H:%M:%S"),
  Period = case_when(Date < as.POSIXct("2025-07-28",tz="","%Y-%m-%d") ~ 1,
                     Date > as.POSIXct("2025-08-18",tz="","%Y-%m-%d") ~ 3,
                     .default = 2),
  ServiceInterval = case_when(Period==1 ~ difftime(Date, as.POSIXct("2025-07-09",tz="","%Y-%m-%d"),units="days"),
                     Period==2 ~ difftime(Date, as.POSIXct("2025-07-28",tz="","%Y-%m-%d"),units="days"),
                     .default = difftime(Date, as.POSIXct("2025-08-18",tz="","%Y-%m-%d"),units="days")),
  LeftRatio = TimeLeft/TimeTotal,
  RightRatio = TimeRight/TimeTotal,
  # actually need to transform to MayoRatio, PBRatio
  #MayoRatio = case_when(LeftTubeTreatment =="M" ~ TimeLeft, .default ~ TimeRight) / TimeTotal, # time left if 
  TotalInteractionRatio = (TimeLeft+TimeRight)/TimeTotal,
  AreaRatio = TimeArea/TimeTotal,
  TotalRatio = (TimeLeft+TimeRight+TimeArea)/TimeTotal,
  Site = paste(Camera,Period,sep="_"),
  # TODO temporary way of including site
  FirstBait = case_when(FirstTube=="L" ~ LeftTubeTreatment, # if the first tube was the left then record the left treatment
                        FirstTube=="R" & LeftTubeTreatment == "M" ~ "P", # if the first tube was the right and the left tube had mayo then record peanut butter as the first bait
                        FirstTube=="R" & LeftTubeTreatment == "P" ~ "M", # if the first tube was the right and the left tube had peanut butter then record mayo as the first bait
                        FirstTube=="R" & LeftTubeTreatment == "C" ~ "C", # if the first tube was the right and the left tube was control then record control as the first bait
                        .default = NA)) # otherwise, no first bait
```

```{r}
# try to group clips by same date and time within 5 minutes
analysis_data_f <- analysis_data_f |> 
  #group_by() |> 
  mutate(difft = abs(as.numeric(difftime(Time, lag(Time, default = first(Time)),units = 'mins')))) |>
  #mutate(diffd = abs(as.numeric(difftime(date, lag(date, default = first(date)),
               #units = 'days')))) %>%
   group_by(grp = cumsum(difft > 5), .add = TRUE) |> 
  summarize(Site=Site[1],Camera=Camera[1], Month=Month[1], Day=Day[1], Time=Time[1], LeftTubeTreatment=LeftTubeTreatment[1], FirstTube=FirstTube[1],TimeLeft = sum(TimeLeft),TimeRight = sum(TimeRight),TimeArea = sum(TimeArea), TimeTotal=sum(TimeTotal), Date=Date[1], Period=Period[1], ServiceInterval=ServiceInterval[1], FirstBait=FirstBait[1]) |>
  mutate(LeftRatio = TimeLeft/TimeTotal,
  RightRatio = TimeRight/TimeTotal,
  # actually need to transform to MayoRatio, PBRatio
  #MayoRatio = case_when(LeftTubeTreatment =="M" ~ TimeLeft, .default ~ TimeRight) / TimeTotal, # time left if 
  TotalInteractionRatio = (TimeLeft+TimeRight)/TimeTotal,
  AreaRatio = TimeArea/TimeTotal,
  TotalRatio = (TimeLeft+TimeRight+TimeArea)/TimeTotal)
   #group_by(grp = cumsum(diffd > 365), add = TRUE) %>%
   #summarise(N = n_distinct(meds)) %>%
   #group_by(ID) %>%
   #summarise(N = max(N))
```

# Interaction Length

```{r}
# actually should probably do it as...
  # tuple: video #, (mayo | pb | control), interaction time
  # interaction time is l or r ratio based on what the left tube treatment is or one entry for each if control

# TODO this is inefficient but maybe that makes it more readable? and that might be more desirable?
  # one immediate streamlining move would be to do left and right pb statements in the mayo and pb statements

# left control tubes only
lcontrol <- analysis_data_f |>
  subset(LeftTubeTreatment=="C") |>
  select(LeftTubeTreatment,TimeLeft,LeftRatio,Period,ServiceInterval,Site) |>
  rename(Treatment=LeftTubeTreatment,InteractionTime=TimeLeft,InteractionRatio=LeftRatio)
# right control tubes only
rcontrol <- analysis_data_f |>
  subset(LeftTubeTreatment=="C") |>
  select(LeftTubeTreatment,TimeRight,RightRatio,Period,ServiceInterval,Site) |>
  rename(Treatment=LeftTubeTreatment,InteractionTime=TimeRight,InteractionRatio=RightRatio)
# mayo tubes only
mayo <- analysis_data_f |>
  subset(LeftTubeTreatment!="C") |>
  mutate(InteractionTime = case_when(LeftTubeTreatment =="M" ~ TimeLeft,
                                     .default = TimeRight),
         InteractionRatio = case_when(LeftTubeTreatment =="M" ~ LeftRatio,
                                     .default = RightRatio),
         Treatment = "M") |>
  select(Treatment,InteractionTime,InteractionRatio,Period,ServiceInterval,Site)
# pb tubes only
pb <- analysis_data_f |>
  subset(LeftTubeTreatment!="C") |>
  mutate(InteractionTime = case_when(LeftTubeTreatment =="P" ~ TimeLeft,
                                     .default = TimeRight),
         InteractionRatio = case_when(LeftTubeTreatment =="P" ~ LeftRatio,
                                     .default = RightRatio),
         Treatment = "P") |>
  select(Treatment,InteractionTime,InteractionRatio,Period,ServiceInterval,Site)

# combine the tube interaction data from both control tubes, mayo, and pb
interaction_treatment_data <-  lcontrol |>
  rows_append(rcontrol) |> 
  rows_append(mayo) |>
  rows_append(pb)


# strat for making the big interaction table
# select all control
# get all left controls
# get all right controls
# select all mayo or pb
# get all mayo ratios
# get all pb ratios
# append mayo and pb tables to the two control tables
  # this lowkey sucks in terms of code readability but it is efficient...

#interaction_treatment_data <- data.frame()
#names(interaction_treatment_data) <- #c("FileName","Treatment","InteractionTime","InteractionRatio")


# interaction time as ratio of video time is...
  # mayo ratio for mayo
  # peanut butter ratio for peanut butter
  # half of total interaction time for control

# not the below
  # mayo ratio if left tube is mayo
  # peanut butter ratio if left tube is peanut butter
  # half of total interaction time if left tube is control


```

```{r}
favstats(~InteractionRatio, data=interaction_treatment_data)

# anova for mean interaction ratio
interaction_anova <- aov(InteractionRatio ~ Treatment,data=interaction_treatment_data)
summary(interaction_anova)
  # entirely wildly this is significant!
# post hoc tukey test
TukeyHSD(interaction_anova)
  # p for pb vs mayo after adjusting is significant with alpha threshold of 0.05 (and actually lower)
```

```{r}
# mean interaction ratio
gf_boxplot(InteractionRatio~Treatment, fill=~Treatment,data=interaction_treatment_data) |>
  gf_labs(y="Proportion of Video Interacting with Tube") + 
  scale_fill_manual(values = c("springgreen3","dodgerblue","darkorange2"),
                    guide="none") +
  scale_x_discrete(labels = c("Control","Mayonnaise","Peanut butter")) +
  theme_classic()
```

```{r}
# mean interaction ratio
gf_histogram(InteractionRatio~"", fill=~Treatment,data=interaction_treatment_data,position="identity") |>
  gf_labs(y="Proportion of Video Interacting with Tube") + 
  scale_fill_manual(values = c("springgreen3","dodgerblue","darkorange2"),
                    guide="none") +
  scale_x_discrete(labels = c("Control","Mayo","Peanut butter")) +
  theme_classic()
```

```{r}
# mixed model to predict interaction length with the time since servicing
interaction_ratio_model <- lmer(InteractionRatio ~ Treatment + ServiceInterval + (1 | Period)+ (1 | Site),data=interaction_treatment_data) #+ (1 | Location) + (1 | TimeOfDay)
summary(interaction_ratio_model)

#TODO maybe visualize this

#We used a linear mixed effects model to predict mean interaction length based on the fixed effects of bait type and time since service as well as the random effects of location, sampling period (first, second, or third round), and time of day. 
```

```{r}
# visualize mixed model somehow
gf_point(InteractionRatio ~ ServiceInterval, color=~Treatment,shape=~as.factor(Period),data=interaction_treatment_data) + scale_color_manual(values = c("springgreen3","dodgerblue","darkorange2")) + theme_classic()
```

```{r}
# visualize mixed model somehow
gf_point(InteractionRatio ~ ServiceInterval, color=~Treatment, shape=~Treatment,data=interaction_treatment_data) |>
  gf_labs(x = "Days since station last serviced", y = "Proportion of video interacting with tube") + scale_color_manual(values = c("springgreen3","dodgerblue","darkorange2"), labels=c("Control", "Mayonnaise","Peanut butter")) + scale_shape_manual(values=c("circle","triangle","square"), labels=c("Control", "Mayonnaise","Peanut butter"))+ theme_classic()
```

```{r}
#interaction_ratio_model <- lmer(InteractionRatio ~ Treatment + ServiceInterval + (1 | Period)+ (1 | Site),data=interaction_treatment_data) #+ (1 | Location) + (1 | TimeOfDay)

ServiceInterval.vec.pred <- seq(min(interaction_treatment_data$ServiceInterval),max(interaction_treatment_data$ServiceInterval),length.out=100)

dat.pred <- expand.grid(ServiceInterval.vec.pred, interaction_treatment_data$Treatment)

colnames(dat.pred) <- c("ServiceInterval","Treatment")

dat.pred$y <- predict(interaction_ratio_model,newdata=dat.pred,re.form=NA)

gf_point(InteractionRatio ~ ServiceInterval, color=~Treatment,shape=~Treatment, data=interaction_treatment_data) |> 
  gf_line(y ~ ServiceInterval, color=~Treatment, data=dat.pred) |>
  gf_labs(x = "Days since station last serviced", y = "Proportion of video interacting with tube") + scale_color_manual(values = c("springgreen3","dodgerblue","darkorange2"), labels=c("Control", "Mayonnaise","Peanut butter")) + scale_shape_manual(values=c("circle","triangle","square"), labels=c("Control", "Mayonnaise","Peanut butter")) +
 theme_classic()
```



# First Interaction Choice

```{r}
#We then tested if there was a significant difference in the number of times rats interacted first with peanut butter versus mayonnaise using a chi-square test.

firstbait_data <- analysis_data_f |> 
  group_by(FirstBait) |>
  summarize(n = n()) |>
  subset(FirstBait == "P" | FirstBait=="M")

firstbait_anova <- aov(n~FirstBait,data=na.omit(firstbait_data))
summary(firstbait_anova)


chisq.test(firstbait_data$n, p=c(0.25,0.25,0.25,0.25))
  # 30 total, 21 mayo or pb, 
  # https://www.sthda.com/english/wiki/chi-square-goodness-of-fit-test-in-r
# x is treatment
# y is # of visits

# how should controls be accounted for here?
# is it best to do multiple comparisons?
  # left vs right for controls to see if its significant
  # then pb vs mayo
  # only issue is that then there's not necessary a way to incorporate that to get pb mayo results after accounting for the directional bias

# just a straight up chi square
```

```{r}
# mixed model to predict first bait with the time since servicing
firstbait_model <- glmer(as.factor(FirstBait) ~ ServiceInterval + (1 | Period)+ (1 | Site),family="binomial",data=analysis_data_f)

summary(firstbait_model)

#tally(~Period,data=analysis_data_f)

# We used a logistic mixed effects model with the same random effects and the fixed effect of time since service to predict which bait type would be chosen first.
```

```{r}
# visualize first bait mixed model
gf_boxplot(FirstBait ~ ServiceInterval, fill=~FirstBait,data=analysis_data_f)

gf_histogram(~ServiceInterval, fill=~FirstBait,data=analysis_data_f,position="identity") + scale_fill_manual(values = c("springgreen3","dodgerblue","darkorange2","grey")) + theme_classic()
```

```{r}
# interactions over time
gf_histogram(~ServiceInterval,data=analysis_data_f)
```

```{r}
# first bait
gf_bar(~FirstBait,fill=~FirstBait,data=analysis_data_f) |>
  gf_labs(x = "First bait choice", y="Count", fill = "First bait choice") + scale_fill_manual(values = c("springgreen3","dodgerblue","darkorange2"), labels = c("Control", "Mayonnaise","Peanut butter", "None")) + scale_x_discrete(labels = c("Control", "Mayonnaise","Peanut butter", "None")) +
  theme_classic()
```

