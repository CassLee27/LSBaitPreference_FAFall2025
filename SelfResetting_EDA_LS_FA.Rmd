---
title: "SelfResetting_EDA_LS_FA"
author: "Cass Lee"
date: "2025-09-15"
output: pdf_document
---

! For best results, run these code chunks sequentially in RStudio rather than creating a knitted document.

## Preliminary Set Up

```{r import libraries}
# import useful libraries
library(tidyverse)
library(mosaic)
library(ggformula)
library(dplyr)
library(lme4)
library(effects)
```

```{r import data}
# set import file path
path <- '~/Desktop/ENVR356/LS_FA/full_data.csv'
# import full data set
all_data <- read_csv(file = path)
```

## EDA and Data Wrangling

```{r problems}
# address initial problems when loading csv
# image links trying to translate to logical
# remove the image column
neat_data <- select(all_data, -Images)
glimpse(data)
```

```{r wrangling}
# rename columns to work better for analysis
colnames(neat_data) <- c("Line", "TrapID", "Code", "TrapType",
                         "TrapSubType", "Tags", "Latitude",
                         "Longitude","Easting","Northing","EntryID",
                         "Date", "Status", "InitialBait", "Rebaited",
                         "BaitType", "BaitDetails", "RecordedBy",
                         "Strikes", "SpeciesCaught", "Sex",
                         "Maturity","TrapCondition", "Notes")
glimpse(neat_data)
# make sure data looks good
  # TODO vaguely weird, maybe come back to this
inspect(data1)
```

```{r}
# EDA for trap type, bait type
tally(~TrapType, data=neat_data)
tally(~BaitType, data=neat_data)
```

```{r}
min(~Date,data=neat_data)
max(~Date,data=neat_data)
```

```{r}
# single kill
# filter to just single kill traps that have mayo or pb as bait
#analysis_data_a <- subset(data1_a, grepl("MAYO", toupper(BaitType)) | grepl("PEANUT BUTTER", toupper(BaitType))) |>
#  subset(!(grepl("AT220", TrapType) | grepl("Sentinel", TrapType) | grepl("Supervisor Max", TrapType)))

# how to distinguish single kill traps
  # 27 unspecified
  # single: cage trap, D-Rat, DOC 200, DOC 250, leg hold trap, rat trap, SA cat, Tāwhiti - Smart Cage, trapinator
    # cage trap, leg hold trap, Tāwhiti - Smart Cage is live capture
    # rat trap resetting type isn't specified but we can probably pretty safely assume it's single trap per set
  # self-resetting: AT220, sentinel, supervisor max
    # sentinel, supervisor max assumed to not be by looking up quickly but actually recorded as having multiple strikes sometimes
# sentinel trap is specifically for possums, supposed to stop rats from getting bait
```

```{r}
#tally(~BaitType, data=analysis_data_a)
# 600 odd just mayo before filtering by just single kill
```

```{r}
# look at the self-resetting trap data to see if it can be made to compare to single kill
resetting <- subset(neat_data, grepl("MAYO", toupper(BaitType)) | grepl("PEANUT BUTTER", toupper(BaitType))) |>
  subset(grepl("AT220", TrapType) | grepl("Sentinel", TrapType) | grepl("Supervisor Max", TrapType))
tally(~BaitType, data=resetting)
resetting[resetting$BaitType=="Mayo",]
  # 680ish plain mayo, 630ish plain pb for self-resetting
```

```{r}
nonresetting <- subset(neat_data, grepl("MAYO", toupper(BaitType)) | grepl("PEANUT BUTTER", toupper(BaitType))) |>
  subset(!(grepl("AT220", TrapType) | grepl("Sentinel", TrapType) | grepl("Supervisor Max", TrapType)))
```

```{r}
# servicing interval for self-resetting traps
# function of choice for the task
avg_interval <- function(id, dates){
  #print(id)
  #print(dates)
  total_interval <- 0
  for (i in 1:(length(dates)-1)){
    total_interval <- total_interval + difftime(dates[i+1],dates[i],units="days")
  }
  #print(total_interval/(length(dates)-1))
  if (length(dates) <= 1){
    return(as.difftime(0,units="days"))
  }
  else{return(total_interval/(length(dates)-1))}
}

times_resetting <- resetting |> group_by(TrapID) |> summarize(AvgInterval = avg_interval(TrapID,Date)[1], n = n())
times_nonresetting <- nonresetting |> group_by(TrapID) |> summarize(AvgInterval = avg_interval(TrapID,Date)[1], n = n())
```

```{r}
# servicing interval for self-resetting traps
# less efficient
intervals <- function(id, dates){
  #print(id)
  #print(dates)
  intervals <- c()
  for (i in 1:(length(dates)-1)){
    intervals <- c(intervals, difftime(dates[i+1],dates[i],units="days"))
  }
  return(intervals)
}

# different formulations for the summarize query
#times2 <- resetting |> group_by(TrapID) |> summarize(AvgInterval = avg_interval(TrapID,Date), MeanInterval = mean(intervals(TrapID,Date)))
#times2 <- resetting |> group_by(TrapID) |> summarize(AvgInterval = avg_interval(TrapID,Date), MeanInterval = mean(intervals(TrapID,Date),na.rm=FALSE))

#times <- resetting |> group_by(TrapID) |> summarize(AvgInterval = avg_interval(TrapID,Date)[1])

#times3 <- resetting |> group_by(TrapID) |> summarize(MeanInterval = mean(intervals(TrapID,Date)))

# tests for the two functions
#print(avg_interval(c(as.POSIXct("2022-02-26 14:25:00"),as.POSIXct("2022-02-27 10:09:00"),as.POSIXct("2022-02-28 10:09:00"))))
#print(intervals(c(as.POSIXct("2022-02-26 14:25:00"),as.POSIXct("2022-02-27 10:09:00"),as.POSIXct("2022-02-28 10:09:00"))))
```

```{r}
# visualize self resetting interval
favstats(~AvgInterval,data=subset(times_resetting,AvgInterval>0))
gf_histogram(~AvgInterval,data=subset(times_resetting,AvgInterval>0)) |> gf_labs(x="Mean days between servicing",y="Trap count") + theme_classic()

table(times_resetting$AvgInterval)
```
```{r}
# visualize non self resetting interval
favstats(~AvgInterval,data=times_nonresetting)
gf_histogram(~AvgInterval,data=times_nonresetting) |> gf_boxplot()
```

The average servicing interval between not resetting and self resetting is meaningfully different 
```{r}
# non parametric two sample mean comparison
wilcox.test(as.numeric(times_nonresetting$AvgInterval),as.numeric(times_resetting$AvgInterval))
  # yup it's different, p < 0.001
```

```{r}
# how many times each trap is reset
favstats(~n, data=times)
gf_histogram(~n,data=times) |> gf_boxplot()
```

```{r}
# servicing interval for self-resetting traps
  # scatter plot with line drawn through
  # x axis is time, strikes is y axis
  # entryid is series
# make more legible by sampling only a few
small_resetting <- resetting |> subset(TrapID %in% sample(unique(TrapID),10))
gf_line(Strikes~Date, color=~as.factor(TrapID),data=small_resetting) |> gf_point()
```

So the solution is to add service interval as a variable to the mixed model (and maybe self resetting? probably not), make the number of strikes just be a boolean of strike or not, and then use all trap types baited with just mayo or just pb

Can also compare just the self resetting with pb and mayo

```{r}
resetting_analysis_data <- subset(resetting, BaitType =="Mayo" | BaitType=="Peanut butter")
```

```{r}
write.csv(resetting_analysis_data,"~/Desktop/ENVR356/LS_FA/self_resetting_trap_data.csv", row.names = FALSE)
```

```{r}
# look at the sample size for just pb and mayo single baits
tally(~BaitType, data=resetting_analysis_data)
  # 680 Mayo, 653 Peanut butter
tally(TrapType~BaitType, data=resetting_analysis_data)
favstats(~Strikes,data=subset(resetting_analysis_data,TrapType=="Sentinel"))
tally(~Strikes,data=subset(resetting_analysis_data,TrapType=="Sentinel"))

tally(~TrapType,data=subset(resetting_analysis_data,Strikes>0))
tally(~Strikes,data=subset(resetting_analysis_data,Strikes>0 &TrapType=="Supervisor Max"))

subset(resetting_analysis_data,Strikes>0&TrapType=="Sentinel")
```

```{r}
trapnz_model <- lmer(Strikes ~ BaitType + (1 | Date), data=resetting_analysis_data)
resetting_analysis_data2 <- resetting_analysis_data |> mutate(Year = format(Date,"%Y"), Month = format(Date,"%m"))
trapnz_model2 <- lmer(Strikes ~ BaitType + (1 | Year) + (1 | Month), data=resetting_analysis_data2)
trapnz_model3 <- lmer(Strikes ~ BaitType + SpeciesCaught + (1 | Year) + (1 | Month), data=resetting_analysis_data2)

resetting_rat <- resetting_analysis_data2 |> mutate(SprungByRat = Strikes>0 & grepl("Rat",SpeciesCaught))

trapnz_model4 <- glmer(SprungByRat ~ BaitType + (1 | Year) + (1 | Month), family=binomial, data=resetting_rat)
summary(trapnz_model4)
```

```{r}
# stats for model
summary(trapnz_model)
summary(trapnz_model2)
summary(trapnz_model3)

#model2 <- lm(Strikes ~ BaitType +Date, data=resetting_analysis_data)
#summary(model2)
  # p value for bait type is very low

```

```{r}
# graph for model
# TODO look up how to graph lmer
date_effect <- as.data.frame(effect(term="BaitType", mod=trapnz_model))

#gf_point(Strikes~BaitType,data=resetting_analysis_data)

gf_point(Strikes~Date,color=~BaitType,shape=~BaitType,data=resetting_analysis_data) |>
  gf_lm() |>
  gf_labs(color="Bait Type",shape="Bait Type") + scale_y_log10() + scale_color_manual(values = c("skyblue","darkorange"))

#gf_point(Strikes~BaitType, data=resetting_analysis_data) |>
#  gf_point(fit~BaitType, data=date_effect,color="red") |>
#  gf_line(fit~BaitType, data=date_effect,color="red") |>
#  gf_ribbon(lower + upper ~ BaitType, data=date_effect, alpha=0.3,fill="red") |>
#  gf_labs()
```

```{r}
gf_boxplot(Strikes~"",fill=~BaitType,data=resetting_analysis_data)
```

```{r}
gf_histogram(Strikes~"" | BaitType,fill=~BaitType,position="identity",data=resetting_analysis_data)

tally(~Strikes,data=subset(resetting_analysis_data,BaitType=="Peanut butter"))
```

```{r}
# mutate to make a sprung or not binary variable
sprung_analysis_data <- mutate(resetting_analysis_data, Sprung = Strikes>0)
```

```{r}
# logistic regression for the sprung analysis data
m <- glm(Sprung~Date+BaitType, sprung_analysis_data,family="binomial")
predict(m)
plot(m)
```

```{r}
# plot logistic regression
gf_point(Sprung~Date,color=~BaitType,shape=~BaitType,data=sprung_analysis_data) |>
  gf_smooth(method ="glm", method.args = list(family ="binomial"),se=FALSE) |>
  gf_labs(color="Bait Type",shape="Bait Type") + scale_color_manual(values = c("skyblue","darkorange"))
  # logistic regression claims not to converge...
```

```{r}

sprung_rat_data <- mutate(resetting_analysis_data, Sprung = Strikes>0 & grepl("Rat",SpeciesCaught))

z.test()
tally(~BaitType,data=sprung_rat_data)
table(sprung_rat_data[,c("BaitType","Sprung")])

#table(BaitType~Sprung,data=subset(sprung_analysis_data, SpeciesCaught=="None" | grepl("Rat",SpeciesCaught)))
```

```{r}
gf_bar(~Sprung,fill=~BaitType,data=sprung_analysis_data)
gf_bar(~BaitType,fill=~Sprung,data=sprung_analysis_data)

gf_bar(~BaitType,position="fill",fill=~Sprung,data=sprung_rat_data) |> gf_labs(x = "Bait type", y = "Proportion of traps", fill="Sprung by rat") + scale_fill_manual(values=c("#F8766D","#00BFC4"), labels = c("False", "True")) + theme_classic()
```

```{r}
tally(~SpeciesCaught, data=resetting_analysis_data)

species_grouped_h <- resetting_analysis_data |>
  mutate(SpeciesCaught = fct_collapse(as.factor(SpeciesCaught),
                                      #Bird = c("Magpie", "Other"),
                                      Rat = c("Rat - Norway","Rat - Ship"), # "Rat - Kiore",
                                      #Mustelid = c("Ferret","Stoat","Weasel"),
                                      #'Other Mammal' = c("Cat","Hedgehog","Possum","Rabbit")
                                      ))|>
           fct_infreq() |> fct_rev()

mosaicplot(BaitType~SpeciesCaught, 
           data=resetting_analysis_data,
           #srt = 45,
           las=2,
           color = c("red", "orange","gold", "green", "blue", "purple"),
           main = "",
           xlab = "Bait",
           ylab = "Caught Species")
```

```{r}
# strikes over time
# sprung by rats over time
gf_histogram(~Date, fill=~BaitType,position="identity", data=sprung_rat_data)
gf_histogram(..density..~Date, fill=~Sprung, data=sprung_rat_data) |>
  gf_labs(y="Trap count", fill="Sprung by rat") + facet_grid(BaitType~.,labeller=labeller("Mayonnaise", "Peanut butter")) + scale_fill_manual(values=c("#F8766D","#00BFC4"), labels = c("False", "True")) + theme_classic()
```

```{r}
all_trap_type_data <- subset(neat_data, BaitType=="Mayo" | BaitType=="Peanut butter") |>
  mutate(SprungRat = (Strikes > 0 & grepl("Rat",SpeciesCaught)))

gf_bar(~BaitType, fill=~SprungRat,data=all_trap_type_data,position="fill")

tally(SprungRat~BaitType,data=all_trap_type_data)

all_trap_type_data2 <- all_trap_type_data |> mutate(Year = format(Date,"%Y"), Month = format(Date,"%m"))

trapnz_model_all <- glmer(SprungRat ~ BaitType + (1 | Year) + (1 | Month), family=binomial, data=all_trap_type_data2)

summary(trapnz_model_all)

trapnz_model_no_time <- glm(SprungRat ~ BaitType, family=binomial, data=all_trap_type_data2)

summary(trapnz_model_no_time)

trapnz_model_all_by_trap <- glmer(SprungRat ~ BaitType + (1|TrapType) + (1 | Year) + (1 | Month), family=binomial, data=all_trap_type_data2)

summary(trapnz_model_all_by_trap)

trapnz_model_all_with_trap <- glmer(SprungRat ~ BaitType * TrapType + (1 | Year) + (1 | Month), family=binomial, data=all_trap_type_data2)
  # try dropping the traps 

tally(BaitType ~ TrapType, data= all_trap_type_data)

summary(trapnz_model_all_with_trap)
```
```{r}
# visualize the bait and trap type model somehow
gf_bar(~BaitType, fill=~SprungRat,data=all_trap_type_data,position="fill") |> gf_labs(y="Percentage of Traps", x = "Bait", fill="Sprung by Rat?") + scale_fill_manual(values = c("#F8766D","#00BFC4"), labels = c("No", "Yes")) + scale_x_discrete(labels = c("Mayonnaise","Peanut butter")) +
  theme_classic()

factor(all_trap_type_data$TrapType,levels=c("AT220","D-Rat","DOC 200","Rat trap","DOC 250","Trapinator","Cage Trap","Leg hold trap","Sentinel","Supervisor Max"))

# for the presentation
gf_bar(~BaitType | TrapType, fill=~SprungRat,data=all_trap_type_data,position="fill") |> gf_labs(y="Trap record count", x = "Bait", fill="Sprung by Rat?") + scale_fill_manual(values = c("#F8766D","#00BFC4"), labels = c("No", "Yes")) + scale_x_discrete(labels = c("","")) +
  theme_classic()

gf_bar(~BaitType, fill=~SprungRat,data=all_trap_type_data) |>
  gf_facet_wrap(~TrapType, scales="free_y") |>
  gf_labs(y="Trap count")

# i want a table of % strike mayo,# mayo, % strike pb, # pb for each trap type
tally(SprungRat~TrapType + BaitType,data=all_trap_type_data)

gf_bar(~BaitType, fill=~SprungRat,data=subset(all_trap_type_data,TrapType=="Sentinel")) |>
  #gf_facet_wrap(~TrapType, scales="free_y") |>
  gf_labs(y="Trap record count", x = "Bait", fill="Sprung by Rat?") + scale_fill_manual(values = c("#F8766D","#00BFC4"), labels = c("No", "Yes")) + scale_x_discrete(labels = c("Mayonnaise","Peanut butter")) +
  theme_classic()

gf_bar(~BaitType, fill=~SprungRat,position="fill",data=subset(all_trap_type_data,TrapType=="Sentinel")) |>
  #gf_facet_wrap(~TrapType, scales="free_y") |>
  gf_labs(y="Trap record count", x = "Bait", fill="Sprung by Rat?") + scale_fill_manual(values = c("#F8766D","#00BFC4"), labels = c("No", "Yes")) + scale_x_discrete(labels = c("Mayonnaise","Peanut butter")) +
  theme_classic()

# sentinel and supervisor are really the interesting results - mayo + sentinel and mayo + supervisor are weirdly effective...
```

```{r}
# AT220, D Rat, DOC 200, Rat trap all have approx equal rat catch rates for the bait types that have a decent number of traps
  # most of these are pb, only AT220 has a mayo finding (but it matches the AT220 pb finding, but that's only 11 traps)

# Sentinel and Supervisor Max both have disproportionately high mayo catches
  # Supervisor Max is low sample size - only 11 mayo obs, but a pretty dramatic effect
  # Sentinel is low overall catch rate - mayo is lower than the standard catch rate and pb is 0

# Cage trap, leg hold trap, doc 250 caught 0 rats
# Trapinator caught 1 rat out of 394 pb traps - 0.25% catch rate which is real bad

```

```{r}
# show the trap types where there are both pb and mayo and any number of strikes

# the ones where 

# more pb for everything except AT220
# strike number
  # notably AT220 has only one strike which is 
  # Trapinator has only 1 strike
# sentinel and supervisor max have more mayo strikes (abs number) despite having far fewer 
# drat and doc 200 have 0 strikes
  # and with a ~10% strike chance each, there's a 52.03% chance of no strikes being observed across only 7 obs with mayo
  # so mayo could well be same rate as pb
# for all 3 trap types with both baits where 

```
